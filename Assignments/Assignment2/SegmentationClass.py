"""
Author: Jake Bova
Date: 12/14/2023
Description: This file contains the code for the Ford-Fulkerson algorithm for image segmentation.
Note: Function docstrings generated by VSCode
"""

# Imports
import numpy as np
import pandas as pd

class SegmentationClass:
    def __init__(self):
        """
        Initializes the FordFulkerson object.
        
        Parameters:
        - p0: Initial path
        - x_a: Flow from source to sink
        - x_b: Flow from sink to source
        
        Returns:
        None
        """
        self.p0 = None
        self.x_a = None
        self.x_b = None
        self.resid_graph = None # For testing

    def set_hyperparameters(self, p0, x_a, x_b):
        """
        Set the hyperparameters for the model.

        Parameters:
        - p0: Initial value for p0.
        - x_a: Array of values for x_a.
        - x_b: Array of values for x_b.
        """
        self.p0 = p0
        self.x_a = np.array(x_a)
        self.x_b = np.array(x_b)

    def euclidean_distance_color(self, rgb1, rgb2):
        """
        Calculates the Euclidean distance between two RGB colors.

        Parameters:
        rgb1 (tuple): The RGB values of the first color.
        rgb2 (tuple): The RGB values of the second color.

        Returns:
        float: The Euclidean distance between the two colors.
        """
        return np.sqrt(np.sum((rgb1 - rgb2) ** 2))
    
    def euclidean_distance_point(self, tuple1, tuple2):
        """
        Calculates the Euclidean distance between two points.

        Parameters:
        tuple1 (tuple): The coordinates of the first point.
        tuple2 (tuple): The coordinates of the second point.

        Returns:
        float: The Euclidean distance between the two points.
        """
        return np.sqrt(np.sum((np.array(tuple1) - np.array(tuple2)) ** 2))

    def calculate_weights_ss(self, I, x):
        if 1:
            a_x = 442 - round(self.euclidean_distance_color(I[tuple(x)], I[tuple(self.x_a)]))
            b_x = 442 - round(self.euclidean_distance_color(I[tuple(x)], I[tuple(self.x_b)]))
        if 0:
            a_x = 442 - round(self.euclidean_distance_point(tuple(x), tuple(self.x_a)))
            b_x = 442 - round(self.euclidean_distance_point(tuple(x), tuple(self.x_b)))
        # print('a_x, b_x: ', a_x, b_x)
        return a_x, b_x
    
    def calculatePixelWeight(self, I, x_i, x_j):
        """
        Calculate the weight between two neighboring pixels.

        Parameters:
        - I: The image array.
        - x_i: The coordinates of the first pixel.
        - x_j: The coordinates of the second pixel.

        Returns:
        - The weight between the two pixels.
        """
        distance = self.euclidean_distance_point(tuple(x_i), tuple(x_j))
        if distance < 2:
            return self.p0
        else:
            return 0

    def construct_adjacency_matrix(self, I):
        """
        Constructs the adjacency matrix for the Ford-Fulkerson algorithm.

        Parameters:
        - I: numpy.ndarray
            Input image array.

        Returns:
        - A: numpy.ndarray
            Adjacency matrix representing the graph.
        """
        N = I.shape[0]
        size = N * N + 2 # Add source and sink to the graph
        A = np.zeros((size, size))

        for i in range(N): # Loop through pixels
            for j in range(N):
                current_pixel = (i, j)
                current_idx = self.idx(current_pixel, N)

                # Weights to source and sink
                a_x, b_x = self.calculate_weights_ss(I, current_pixel)
                A[size - 2][current_idx] = a_x  # Edge from super-source
                A[current_idx][size - 1] = b_x  # Edge to super-sink

                # Weights between neighboring pixels
                for i_i in range(-1, 2): # Loop through neighboring pixels
                    for j_j in range(-1, 2):
                        if i_i == 0 and j_j == 0: # Skip current pixel
                            continue
                        ni, nj = i + i_i, j + j_j # Neighbor pixel coordinates
                        if 0 <= ni < N and 0 <= nj < N: # Check if neighbor is within bounds
                            neighbor_idx = self.idx((ni, nj), N)
                            weight = self.calculatePixelWeight(I, (i, j), (ni, nj)) # Calculate weight between pixels
                            A[current_idx][neighbor_idx] = weight # Edge from current pixel to neighbor

        self.resid_graph = A

        return A

    def idx(self, x, N):
        """
        Convert 2D coordinates to 1D index.

        Parameters:
        - x: Tuple of 2D coordinates (x, y)
        - N: Size of the grid (N x N)

        Returns:
        - Index corresponding to the given coordinates in a 1D array
        """
        return x[0] * N + x[1]
    

    def ford_fulkerson(self, graph, source, sink):
        """
        Implements the Ford-Fulkerson algorithm to find the maximum flow in a graph.

        Args:
            graph (List[List[int]]): The graph represented as an adjacency matrix.
            source (int): The source node.
            sink (int): The sink node.

        Returns:
            Tuple[int, List[int]]: A tuple containing the maximum flow value and the vertices on the source side of the min cut.
        """
        parent = [-1] * len(graph)  # Array to store the path (parent of 'current' node)
        max_flow = 0  # Initial flow is 0

        def bfs(resid_graph, source, sink, parent):
            """
            Perform a Breadth-First Search (BFS) on the residual graph to find a path from the source to the sink.

            Parameters:
            - resid_graph (list of lists): The residual graph represented as an adjacency matrix.
            - source (int): The index of the source node.
            - sink (int): The index of the sink node.
            - parent (list): A list to store the parent nodes of each visited node.

            Returns:
            - bool: True if there is a path from the source to the sink, False otherwise.
            """
            visited = [False] * len(resid_graph)
            queue = []
            queue.append(source)
            visited[source] = True

            while queue:
                u = queue.pop(0)
                for ind, val in enumerate(resid_graph[u]):
                    if visited[ind] == False and val > 0:
                        queue.append(ind)
                        visited[ind] = True
                        parent[ind] = u

            return visited[sink]

        while bfs(graph, source, sink, parent): # While there is a path from source to sink
            # Neat trick: we modify graph in place, so we don't need to keep track of the residual graph
            # graph[u][v] is the capacity of edge u-v
            # graph[v][u] is the residual capacity of edge v-u
            # so the upper right triangle of the matrix is the capacity, and the lower left triangle is the residual capacity
            path_flow = float("Inf")
            s = sink
            while(s != source): # Find the minimum value in the path
                path_flow = min(path_flow, graph[parent[s]][s]) 
                s = parent[s] # Move to the parent node

            max_flow += path_flow # Add path flow to overall flow
            v = sink
            while(v != source): # Update the residual capacities of the edges and reverse edges along the path
                u = parent[v] 
                graph[u][v] -= path_flow # Forward edge
                graph[v][u] += path_flow # Backward edge
                v = parent[v] # Move to the parent node

        # After finding the max flow, perform a DFS from source to find the min-cut
        def dfs(resid_graph, source, visited):
            """
            Depth-first search algorithm to traverse a residual graph.

            Parameters:
            - resid_graph (list of lists): The residual graph represented as an adjacency matrix.
            - source (int): The source node to start the traversal from.
            - visited (list of bool): A list to keep track of visited nodes.

            Returns:
            None
            """
            visited[source] = True
            for i, val in enumerate(resid_graph[source]):
                if not visited[i] and val > 0: 
                    dfs(resid_graph, i, visited)

        visited = [False] * len(graph)
        dfs(graph, source, visited)

        # The vertices visited by DFS are on the source side of the min cut
        min_cut = [i for i in range(len(visited)) if visited[i]]

        return max_flow, min_cut

    def segment_image(self, I):
            """
            Segments the input image using the Ford-Fulkerson algorithm.

            Parameters:
            - I: numpy.ndarray
                The input image.

            Returns:
            - mask: numpy.ndarray
                The mask representing the foreground pixels.
            """
            N = I.shape[0]
            A = self.construct_adjacency_matrix(I)
            max_flow, min_cut = self.ford_fulkerson(A, N * N, N * N + 1)
            print('Max flow: ', max_flow)
            print('Min cut: ', min_cut)
            mask = np.zeros((N, N))
            for i in range(N):
                for j in range(N):
                    if self.idx((i, j), N) in min_cut:
                        mask[i][j] = 1
            return mask